<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Weather Forecast</title>
  <!-- Load Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <!-- <script src="https://cdn.plot.ly/plotly-latest.min.js"></script> -->
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    #controls {
      margin: 10px;
    }
    #plot {
      width: 100vw;
      height: calc(100vh - 100px); /* Fill window, minus some space for controls */
    }
  </style>
</head>
<body>

  <!-- Controls: dropdowns for location & model -->
  <div id="controls">
    <label for="locationSelect">Location:</label>
    <select id="locationSelect"></select>

    <label for="modelSelect">Model:</label>
    <select id="modelSelect"></select>
  </div>

  <div id="plot"></div>

  <script>
    // ------------------------------
    // 1) Define Available Locations & Models
    // ------------------------------
    const locations = [
      { name: "Konstanz", lat: 47.6952, lon: 9.1307 },
      { name: "Chäserrugg", lat: 47.1549, lon: 9.3128 },
      { name: "Zurich", lat: 47.3769, lon: 8.5417 }
    ];

    const models = [
      { label: "DWD Seamless", value: "icon_seamless" },
      { label: "DWD ICON D2", value: "dwd_icon_d2" },
      { label: "MeteoFrance Seamless", value: "meteofrance_seamless" }
    ];

    // Insert location options
    const locSelect = document.getElementById("locationSelect");
    locations.forEach((loc) => {
      const opt = document.createElement("option");
      opt.value = JSON.stringify({ lat: loc.lat, lon: loc.lon });
      opt.textContent = loc.name;
      locSelect.appendChild(opt);
    });

    // Insert model options
    const modSelect = document.getElementById("modelSelect");
    models.forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m.value;
      opt.textContent = m.label;
      modSelect.appendChild(opt);
    });

    // Default selection
    locSelect.selectedIndex = 0;        // Konstanz
    modSelect.selectedIndex = 0;        // DWD ICON D2

    // ------------------------------
    // 2) Build Plot Function
    // ------------------------------
    
    function fetchAndPlot() {
      // Read user selections
      const selectedLoc = JSON.parse(locSelect.value); // {lat, lon}
      const selectedModel = modSelect.value;

      // Hourly variables
      const hourlyVars = [
        "temperature_2m", "relative_humidity_2m", "dew_point_2m",
        "precipitation", "precipitation_probability", "weather_code",
        "cloud_cover", "cloud_cover_low", "cloud_cover_mid",
        "cloud_cover_high", "visibility"
      ];

      // Build Open-Meteo API URL
      const params = {
        latitude: selectedLoc.lat,
        longitude: selectedLoc.lon,
        hourly: hourlyVars,
        models: [selectedModel]
      };

      const queryString = new URLSearchParams(params).toString();
      const apiUrl = "https://api.open-meteo.com/v1/forecast?" + queryString;

      // Convert UTC to German local time
      const convertToGermanTime = (utcString) => {
        const utcDate = new Date(utcString + "Z");
        return new Date(utcDate.toLocaleString("en-US", { timeZone: "Europe/Berlin" }));
      };

      // Fetch data & plot
      fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
          const hourly = data.hourly;
          if(!hourly || !hourly.time) {
            console.error("Invalid data:", data);
            return;
          }

          // Convert times to local
          const timesLocal = hourly.time.map(t => convertToGermanTime(t));

          // Extract arrays
          const temperature = hourly.temperature_2m || [];
          const dewPoint = hourly.dew_point_2m || [];
          const humidity = hourly.relative_humidity_2m || [];
          const precipitation = hourly.precipitation || [];
          const precipProb = hourly.precipitation_probability || [];
          const cloudCover = hourly.cloud_cover || [];
          const cloudCoverLow = hourly.cloud_cover_low || [];
          const cloudCoverMid = hourly.cloud_cover_mid || [];
          const cloudCoverHigh = hourly.cloud_cover_high || [];
          const visibility = (hourly.visibility || []).map(v => v / 1000); // in km
          const weatherCode = hourly.weather_code || [];

          // Weather icons
          const weatherIconMap = {
            "0": "☀️", "1": "🌤️", "2": "⛅", "3": "☁️",
            "45": "🌫️", "48": "🌫️", "51": "🌦️", "53": "🌦️",
            "55": "🌦️", "56": "🌧️", "57": "🌧️", "61": "🌧️",
            "63": "🌧️", "65": "🌧️", "66": "🌧️", "67": "🌧️",
            "71": "🌨️", "73": "🌨️", "75": "🌨️", "77": "❄️",
            "80": "🌦️", "81": "🌦️", "82": "🌧️", "85": "🌨️",
            "86": "🌨️", "95": "⛈️", "96": "⛈️", "99": "⛈️"
          };
          const weatherIcons = weatherCode.map(code => weatherIconMap[code] || "");

          // Cloud cover "tiles"
          const scaleCloud = (values, center) => {
            const up = values.map(v => center + (v / 4));
            const down = values.map(v => center - (v / 4));
            return { up, down };
          };
          const lowCloud = scaleCloud(cloudCoverLow, 25);
          const midCloud = scaleCloud(cloudCoverMid, 50);
          const highCloud = scaleCloud(cloudCoverHigh, 75);
          const xMirror = timesLocal.concat([...timesLocal].reverse());

          // "Now" vertical line
          const now_local = new Date();
          const shapeNow = { 
            type: 'line',
            x0: now_local.toISOString(),
            x1: now_local.toISOString(),
            y0: 0,
            y1: 1,
            xref: 'x',
            yref: 'paper',
            line: { color: 'red', dash: 'dash', width: 2 }
        };

          // Build traces
          const traceTemp = { x: timesLocal, y: temperature, mode: 'lines', name: 'Temperature (°C)', line: { color: 'red' }, yaxis: "y1" };
          const traceDew = { x: timesLocal, y: dewPoint, mode: 'lines', name: 'Dew Point (°C)', line: { color: 'blue', width: 1, dash: 'dot' }, opacity: 0.6, yaxis: "y1" };
          const traceHum = { x: timesLocal, y: humidity, mode: 'lines', name: 'Humidity (%)', line: { color: 'royalblue' }, yaxis: "y2" };

          const tracePrecip = { x: timesLocal, y: precipitation, type: 'bar', name: 'Precip (mm)', marker: { color: 'skyblue' }, yaxis: "y3" };
          const tracePrecipProb = { x: timesLocal, y: precipProb, mode: 'lines', name: 'Precip Prob (%)', line: { color: 'green' }, yaxis: "y4" };

          const traceCloudLow = { x: xMirror, y: lowCloud.up.concat(lowCloud.down.reverse()), fill: 'toself', mode: 'lines', name: 'Cloud Cover Low', line: { color: 'lightblue', width: 1 }, opacity: 0.6, yaxis: "y5" };
          const traceCloudMid = { x: xMirror, y: midCloud.up.concat(midCloud.down.reverse()), fill: 'toself', mode: 'lines', name: 'Cloud Cover Mid', line: { color: 'gray', width: 1 }, opacity: 0.6, yaxis: "y5" };
          const traceCloudHigh = { x: xMirror, y: highCloud.up.concat(highCloud.down.reverse()), fill: 'toself', mode: 'lines', name: 'Cloud Cover High', line: { color: 'black', width: 1 }, opacity: 0.6, yaxis: "y5" };
          const traceCloudTotal = { x: timesLocal, y: cloudCover, mode: 'lines', name: 'Total Cloud Cover', line: { color: 'black', width: 2 }, yaxis: "y5" };

          const traceVisibility = { x: timesLocal, y: visibility, mode: 'lines', name: 'Visibility (km)', line: { color: 'brown', width: 2, dash: 'dot' }, yaxis: "y6" };

          const traceIcons = {
            x: timesLocal,
            y: temperature.map(t => t + 1),
            mode: 'text',
            text: weatherIcons,
            textfont: { size: 18 },
            name: 'Weather',
            yaxis: "y1"
          };

          const allTraces = [
            traceTemp, traceDew, traceHum, traceIcons,
            tracePrecip, tracePrecipProb,
            traceCloudLow, traceCloudMid, traceCloudHigh, traceCloudTotal,
            traceVisibility
          ];

          const layout = {
            title: `Weather Forecast (${selectedModel}) for ${selectedLoc.lat}°N, ${selectedLoc.lon}°E`,
            width: window.innerWidth,   // fill browser width
            height: window.innerHeight * 0.8,  // dynamic height
            grid: { rows: 3, columns: 1, pattern: 'independent' },

            xaxis: { title: "Time (CET/CEST)", tickformat: "%Y-%m-%d<br>%A %H:%M", dtick: 12 * 3600 * 1000 },
            yaxis: { title: "Temp (°C) & Dew", domain: [0.7, 1] },
            yaxis2: { title: "Humidity (%)", overlaying: "y", side: "right" },

            yaxis3: { title: "Precip (mm)", domain: [0.35, 0.7] },
            yaxis4: { title: "Precip Prob (%)", overlaying: "y3", side: "right" },

            yaxis5: { title: "Cloud Cover (%)", domain: [0, 0.35] },
            yaxis6: { title: "Visibility (km)", overlaying: "y5", side: "right", range: [0, 10] },

            shapes: [ shapeNow ]  // Oops, let's fix it properly below
          };

          // We can't define shapeNow inline, so let's define it properly:
          layout.shapes = [{
            type: 'line',
            x0: now_local,
            x1: now_local,
            y0: 0.2,
            y1: 1,
            xref: 'x',
            yref: 'paper',
            line: { color: 'red', dash: 'dash', width: 2 }
          }];

          Plotly.newPlot('plot', allTraces, layout);
        })
        .catch(error => console.error(error));
    }

    // Initialize the plot with default selections
    fetchAndPlot();

    // If user changes location or model, re-plot
    document.getElementById("locationSelect").addEventListener("change", fetchAndPlot);
    document.getElementById("modelSelect").addEventListener("change", fetchAndPlot);
  </script>
</body>
</html>